# 执行上下文与作用域

## 执行上下文

执行上下文的概念在 JavaScript 中非常重要，变量或函数的上下文决定了他们可以访问哪些数据，以及它们的行为。每一个执行上下文都有与之关联的**变量对象**，在函数中它叫做**活动对象**，只在函数执行期间存在。可以把它理解为存放变量的对象，在每个执行上下文中，所有的变量和函数都存在于这个对象上。

> 注意：未经声明便初始化的变量将被添加到全局上下文的变量对象中。

全局上下文是最外层的上下文，即 window。根据宿主环境的不同，全局上下文的变量对象可能不一样。执行上下文一般分为三类，全局上下文、函数上下文以及 eval()。上下文在其内部代码执行完毕后会被销毁，包括其中的变量和函数。每个程序都会有多个上下文，JavaScript 引擎以栈的方式来处理它们，其中栈的最底部是全局上下文。

每个函数都有自己的上下文，当代码执行到该函数调用时，对应的函数上下文便进入上下文栈，在函数执行完毕后，上下文栈便将之弹出，控制权交给新的栈顶上下文。比如以下代码：

```javascript
var color = 'blue';

function changeColor() {
  var anotherColor = 'red';
  function swapColors() {
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
  }
  swapColors();
}
changeColor();
```

当程序执行到 `changeColor();` 时，changeColor 函数的上下文入栈，遇到 `swapColors();` 时，swapColors 函数的上下文入栈，直到其中的代码执行完毕，这两个上下文环境依次从栈顶弹出，控制权回到全局上下文手中。

## 变量声明与作用域

ES6 之前，只能通过 var 声明变量，ES6 之后，加入了 let 和 const 声明。

1. **使用 var 的函数作用域声明**
   在使用 var 声明变量是，变量会被自动添加到最接近的上下文中。在函数中，最接近的上下文是函数的局部上下文。这也就是为什么在函数中声明的变量外部访问不到的原因。
   var 声明的变量会被拿到函数或全局作用域的顶部，这个过程叫变量提升：

   ```javascript
   console.log(a); // undefined
   var a = 10;
   ```

2. **使用 let 的块级作用域声明**
   块级作用域由最近的一对'{}'界定。 除了作用域的不同，let 在同一作用域中不能声明两次，var 的话会忽略前面的声明。严格的说，let 声明的变量也会被提升，但是由于“暂时性死区”，在初始化之前不能使用 let 变量：

   ```javascript
   console.log(b); // ReferenceError: Cannot access 'b' before initialization
   let b = 10;
   ```

3. **使用 const 的常量声明**
   使用 const 声明的变量必须同时初始化为某个值，一经声明在其生命周期的任何时候不可以再重新赋值。对于 const 声明的对象，其引用不可以再修改，但是对象的属性和属性值可以被改变。除了这些，const 和 let 在其他方面是一致的。

> Ps：由于 const 声明变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不是通过查询表进行变量查询，谷歌的 V8 执行的也是这种优化。所以说，在开发过程中，除非确定变量在未来一定会发生改变，否则尽量都使用 const 来声明，这样既可以提前发现重新赋值导致的 bug，也可以提升一点性能。

在特定的上下文读取或写入而引用标识符时，必须通过搜索查找该标识符以确定它表示什么。搜索过程沿着作用域链进行（对于上下文中的变量，如果是对象的话，还会对它的**原型链**进行深度查找），如果找到则搜索停止，变量确定；如果找不到则沿着作用域链继续网上找，知道搜索完全局上下文的变量对象，仍未找到说明未声明。

> Ps：访问局部变量比访问全局变量快的多，因为不用切换作用域。

## 作用域链

上下文中的代码在执行过程中，会创建一条由变量对象组成的作用域链，代码正在执行的上下文对应的变量对象处于作用域链的最前端，然后依次是上一层上下文中的变量对象，再上一层的变量对象...直到全局上下文中的变量对象。

> Ps：通过 var 声明的全局变量和函数都会成为全局上下文中的属性和方法，而 let 和 const 的顶级声明不会定义在全局上下文中，但是在作用域链解析的效果上是一样的。

还是刚才那个例子：

```javascript
var color = 'blue';

function changeColor() {
  var anotherColor = 'red';
  function swapColors() {
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
    // 可以访问到 color、anotherColor 和 tempColor
  }
  swapColors();
  // 可以访问到 color、anotherColor，不能访问到 tempColor  
}
// 只能访问到 color
changeColor();
```

这是因为作用域链是往外连接的，内部上下文可以通过作用域链访问到外部上下文的一切，而外部的上下文无法访问到内部上下文的任何东西。

作用域链可以通过 try/catch 语句的 catch块或者 with 增强。对于 with 来说，会向作用域链前端添加指定的对象；对于catch 语句来说，则会创建一个新的变量对象，这个变量对象包含要抛出的错误对象的声明。这两种增强，都是向作用域链的最前端添加对象。

## 引申：Global 与 window

在 JavaScript 中，其实是不存在全局变量或全局函数这种东西，所有全局作用域中定义的变量和函数都会变成 Global 对象的属性，包括一些全局使用的方法甚至引用类型的构造函数，都是 Global 的方法与属性。而 window，是 Global 在浏览器中充当类似代理的角色。 

>  Ps：除此之外，在全局作用域中，还有一个 Math 对象，它包含完成复杂计算的属性和方法。

