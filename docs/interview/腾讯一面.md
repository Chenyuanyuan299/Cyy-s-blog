# 腾讯一面

## 进程和线程的区别

进程是并发执行的程序在执行过程中分配和管理资源的基本单位。线程是进程的一个执行单元，是比进程还要小的独立运行的基本单位。一个程序至少有一个进程，一个进程至少有一个线程。进程是资源分配最小单位，线程是程序执行的最小单位。

进程有自己独立的地址空间，进程之间的资源是独立的，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段；线程没有独立的地址空间，同一进程的线程共享本进程的地址空间。

每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

## 事件循环机制

Javascript 是单线程的，为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，于是引入了 Event Loop。

事件执行分为同步和异步，当解析器执行的时候会先查看当前要执行的代码是同步还是异步，如果是同步的话就会放入执行栈主线程中去执行，如果是异步会放入 `Event Table` 中，等到异步任务完成后将回调放入 `Event Queue` 中，等主线程执行完执行栈里的代码后，就会去读取异步队列 `Event Queue`，如果有函数就取出来执行。

### 宏任务与微任务

宏任务（macrotask）：script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）

微任务（microtask）：Promise、MutaionObserver、process.nextTick(node.js环境)

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被分配到对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行微任务队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈，然后一直循环。

## p2p 怎么实现的

## TCP 和 UDP 的区别

- 是否基于连接：TCP 面向连接；UDP 面向无连接
- 可靠和有序：TCP 提供交付保证，无差错，不丢失，不重复，且按序到达；UDP 不提供任何有序保证
- 实时性与速度：TCP 要先建立连接，所以速度较慢；UDP 具有更好的实时性，适用于高速传输和对实时性要求高的通信或者广播
- 协议首部大小：TCP 20字节；UDP 8字节
- 拥塞控制：UDP 没有拥塞控制
- 数据模式：TCP 面向字节流；UDP 面向报文
- 应用：每一条 TCP 只能点到点；UDP 支持一对一，一对多，多对多

HTTP 基于 TCP 协议。

## GET 和 POST 的区别

- GET 参数通过 url 传递，POST 放在 request body 中。
- GET 请求在 url 中传递的参数是有长度限制的，而 POST 没有。
- GET 比 POST 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览历史记录里,而 POST 中的参数不会被保留。
- GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
- GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。

## iframe 的假死现象

## CORS 的简单请求和复杂请求

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)X只能[同源](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

对于简单请求来说，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 `Origin` 字段。

## JSONP 实现原理

主要就是利用了 `script` 标签的 `src` 没有跨域限制来完成的。

前端定义一个解析函数(如：`jsonpCallback = function (res) {}`)

通过 `params` 的形式包装 `script` 标签的请求参数，并且声明执行函数(如`cb=jsonpCallback`)

后端获取到前端声明的执行函数(`jsonpCallback`)，并以带上参数且调用执行函数的方式传递给前端

前端在 `script` 标签返回资源的时候就会去执行`jsonpCallback`并通过回调函数的方式拿到数据了。

## csrf攻击和预防

## 场景题：客户端 a.qq.com 服务端 b.qq.com，客户端向服务端请求数据要携带哪个cookie（同源怎么发起csrf攻击）

## 场景题：登录一次之后，下一次不需要再登录是怎么实现的



cookie和localstorage的区别

强缓存和协商缓存

场景题：发送新版本之后怎么让用户强制更新

通过什么请求获取后端数据

node怎么连接后端数据

