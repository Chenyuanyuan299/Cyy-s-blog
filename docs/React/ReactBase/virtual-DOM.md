# React 虚拟 DOM

当每次 state 或者  props 改变的时候，React 都会执行 render()。

当有以下情况：

**情况一**：

1. 拿到 state 数据
2. JSX 模版
3. 数据＋模版结合，生成真实的DOM，显示
4. state 发生改变
5. 数据+模版结合，生成真实的DOM，替换原始的 DOM

这是最笨的一种方式来实现 DOM 的更新，它有以下缺陷：

- 第一次生成了一个完整的DOM片段，消耗性能
- 第二次生成了一个完整的DOM片段，消耗性能
- 第二次的 DOM 替换第一次的 DOM，非常耗性能

针对情况一的问题，试想**情况二**：

1. 拿到 state 数据
2. JSX 模版
3. 数据＋模版结合，生成真实的 DOM，显示
4. state 发生改变
5. 数据＋模版结合，生成真实的 DOM，并不直接替换原始的 DOM
6. 新的 DOM(DocumentFragment) 和原始的 DOM 做比对,找差异
7. 找出某个标签/元素发生了变化
8. 只用新的 DOM 中的该元素，替换掉老的 DOM 中的该元素

用先对比的方式替换原来全部替换的方式，这样做会有一定的性能提升，但是也有一定的缺陷：

- 对比算法也需要性能，性能提升并不明显

**情况三：React的做法**

1. state 数据
2. JSX 模版
3. 生成虚拟DOM（虚拟 DOM 就是一个JS对象，用它来描述真实 DOM)，这一步有一定的性能损耗，但是不高(JS -> JS < JS -> DOM)
4. 数据+模版结合,生成真实的 DOM，来显示
5. state 发生变化
6. 生成新的虚拟 DOM（相对于原来生成新的 DOM，极大提升性能）
7. 比较原始虚拟 DOM 和新的虚拟 DOM 的区别（两个 JS 对象的比对比原来 DOM 结点的比对性能消耗更小，极大提升性能）
8. 直接操作 DOM，改变区别中的内容

总结，在一些情况下，使用虚拟 DOM 可能会更消耗性能，但是在大部分情况下，它能极大的提高性能。

## React.createElement

JSX 模板里的并不是真实的 DOM，实际上会先通过 React.createElement 转换成虚拟 DOM (JS 对象)，然后再转换成真实的 DOM。

## 优点

1. 首先性能在大部分情况下会提升。
2. 虚拟 DOM 使跨端应用得以实现，React Native 便是一个体现。这是因为，原来的情况下 DOM 并不能在移动端被渲染，但是虚拟 DOM 可以被移动端识别，生成移动端能够渲染的组件。

## Diff 算法

主要用在原始虚拟 DOM 和新的虚拟 DOM 的比对。

首先思考 state 的改变。归根到底，重新渲染只会发生在 state 发生改变的情况下（props 即父组件的 state），也就是使用了 setState 函数。如果在短时间内，连续几次改变 state，React 可能会做好几次虚拟 DOM 的比对，这样非常耗费性能。于是 **setState 函数被设计成异步**，React 可以把多次 setState 合并成一个，然后只做一次虚拟 DOM 的比对，这样就可以节省很多性能。

Diff 算法会进行同层的 DOM 比对，一旦上层 DOM 结点不匹配，就会把底下所有结点删除，这可能会造成一些性能的浪费（比如父结点改变，但子结点都一样），但是同层比对的速度会非常的快，减少了比对的时间性能消耗。

在循环中 key 值的加入同时也有利于 Diff 算法的比对，通过两个相同的 key 值对应结点的对比，很快就可以得出比对结果。同时这也是为什么 key 值不要是 index 的原因，因为一旦删除某个列表结点，后面的 key 值和结点将会发生错位：

```javascript
1: a
2: b
3: c

// 删除2结点
1: a
2: c
```

这样会让 Diff 算法误以为结点发生改变从而重新渲染。

