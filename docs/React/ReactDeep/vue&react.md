# Vue 和 React

## 前端框架的分类

下面的公式几乎可以概括所有现代前端框架的实现原理：

```JavaScript
UI = f(state)
```

其中：

- state 代表“当前视图状态”；
- f 代表“框架内部运行环境”；
- UI 代表“宿主环境的视图”。

描述 UI 主要分为模版语法以及 JSX 的方式，React 认为“UI 本质上与逻辑存在耦合的部分”，使用了 JSX 的方式，在 UI 上直接绑定事件，在状态变化后改变 UI 的样式与结构。Vue 则采用了模版语法。模版语法的出发点是，既然前端框架使用 HTML 描述 UI，那就扩展 HTML 的语法，来描述逻辑，即“从 UI 出发，扩展 UI，描述逻辑”。JSX 的出发点是，既然前端框架使用 ES 描述逻辑，就扩展 ES 语法，使它能够描述 UI，即“从逻辑出发，扩展逻辑，描述 UI”。

在上述公式中，state 本质是自变量，自变量通过直接或间接的方式改变 UI（此处 UI 仅仅是对实际宿主环境 UI 的描述），两者之间的描述可以抽象为：

- 自变量与 UI 的对应关系（元素 -> UI）
- 自变量与组件的对应关系（元素 -> 组件 -> UI）
- 自变量与应用的关系（元素 -> 组件 -> 应用 -> UI）

这三种抽象分别对应了三类前端框架：

- 元素级框架（Svelte、Solid.js）
- 组件级框架（Vue）
- 应用级框架（React）

## 前端框架使用的技术

### 细粒度更新

在 React 中，定义因变量时需要显式指明“因变量依赖的自变量”，比如：

```javascript
// React
const y = useMemo(() => x * 2 + 1, [x])
```

而 Vue、Mobx 中并不需要显式指明，它们使用的“能自动追踪依赖的技术”被称为“细粒度更新”：

```javascript
// Vue
const y = computed(() => x.value * 2 + 1)
// Mobx
const y = computed(() => x.data * 2 + 1)
```

细粒度更新有两个显著优点：

- 无需显式指明依赖
- 可以自动追踪依赖

虽然 React 也可以实现细粒度更新，但是 React 属于应用级框架，其更新的细粒度不需要很细。作为代价，React Hooks 在使用上会受到与上述两个优点对应的两种限制。

### AOT

现代前端框架都需要“编译这一步骤”，用于：

- 将 UI 转换为宿主环境可识别的代码；
- 代码转化，比如 ts 到 js，实现 polyfill 等；
- 执行一些编译时优化；
- 代码打包、压缩、混淆。

编译可以选择两个时机执行：

- 代码在构建时，称为 AOT（Ahead Of Time，提前编译或预编译），宿主环境获得的是编译后的代码；
- 代码在宿主环境执行时，称为 JIT（Just In Time，即时编译），代码在宿主环境中编译并执行。

借助 AOT 可以对模版语法编译时进行优化，从而减少根据自变量变化计算出 UI 变化的开销，因为模版语法是固定的，固定意味着可分析，可分析意味着在编译时可以标记模版语法的静态部分和动态部分，从而在寻找“变化的 UI”时可以跳过静态部分。

“采用 JSX 描述 UI”的前端框架则很难从 AOT 中受益，因为 JSX 是 ES 的语法糖，ES 语句的灵活性使其很难进行静态分析。有两个思路可以实现“采用 JSX 描述 UI”的前端框架在 AOT 中受益：

- 使用新的 AOT 实现
- 约束 JSX 的灵活性

### Virtual DOM

所谓虚拟 DOM，其工作原理主要是：

- 将“元素描述的 UI”转化为“VDOM 描述的 UI”
- 对比变化前后“VDOM 描述的 UI”，计算出 UI 中发生变化的部分。

Vue 使用模版语法描述 UI，编译为 render 函数；React 使用 JSX 描述 UI，编译为 createElement 方法。

VDOM 有以下三个优点：

- 相对于真实 DOM，体积更小。DOM 包含了非常多的属性和方法。
- 相较于 AOT 更强大的描述能力。
- 多平台渲染的抽象能力。

## 前端框架的实现原理

从编译时还是运行时上看：

- Svelte 是极致的编译时框架
- React 是极致的运行时框架
- Vue 3 同时拥有两者的特性（AOT 和 VDOM），比较均衡。
